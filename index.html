<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Жесты рук в браузере — демо с MediaPipe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <style>
    :root{
      --bg1: #0f1225;
      --bg2: #0c1b2a;
      --glass:#101528cc;
      --text:#e9ecf1;
      --muted:#a8b3c9;
      --accent1:#7c5cff;
      --accent2:#00d1ff;
      --accent3:#00ffa3;
      --danger:#ff5c7a;
      --ok:#4ade80;
      --warn:#fbbf24;
      --shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
      --radius: 18px;
      --ring: 0 0 0 2px rgba(255,255,255,.05), 0 0 0 6px rgba(124,92,255,.15);
      --grad: radial-gradient(1200px 600px at 20% -10%, rgba(124,92,255,.25), transparent 50%),
              radial-gradient(1200px 600px at 120% 10%, rgba(0,209,255,.18), transparent 55%),
              radial-gradient(900px 500px at 50% 130%, rgba(0,255,163,.15), transparent 50%),
              linear-gradient(180deg, var(--bg1), var(--bg2));
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background: var(--grad) fixed;
      overflow-x:hidden;
    }

    /* Layout */
    .app{display:grid; grid-template-rows:auto 1fr auto; min-height:100dvh; gap:16px}
    header{
      position:sticky; top:0; z-index:50; backdrop-filter:saturate(130%) blur(10px);
      background:linear-gradient(180deg, rgba(16,21,40,.9), rgba(16,21,40,.6));
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .nav{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px clamp(12px, 3vw, 28px);
      max-width:1200px; margin:0 auto;
    }
    .brand{display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.2px}
    .logo{
      width:36px; height:36px; border-radius:12px; background:
      conic-gradient(from 180deg, var(--accent2), var(--accent1), var(--accent3), var(--accent2));
      box-shadow: var(--ring); position:relative; overflow:hidden;
    }
    .logo::after{
      content:""; position:absolute; inset:2px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.02));
      box-shadow: inset 0 0 40px rgba(255,255,255,.05);
    }
    .nav-right{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08); box-shadow:var(--shadow); font-size:12px; color:var(--muted);
    }
    .btn{
      appearance:none; border:0; border-radius:12px; padding:10px 14px; font-weight:600; color:#0b0f18; cursor:pointer;
      background:linear-gradient(180deg, #fff, #f1f5ff);
      transition: transform .12s ease, box-shadow .12s ease, background .3s ease;
      box-shadow:0 6px 20px rgba(124,92,255,.25), inset 0 1px 0 rgba(255,255,255,.7);
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.secondary{
      color:var(--text); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.09);
      box-shadow:var(--shadow)
    }

    main{max-width:1200px; width:100%; margin:0 auto; padding: 0 clamp(12px, 3vw, 28px) 28px}
    .grid{
      display:grid; gap:18px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    /* Video + overlay */
    .stage{
      position:relative; border-radius: var(--radius);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08); box-shadow: var(--shadow); overflow:hidden; min-height: 420px;
    }
    .video-wrap{
      position:relative; aspect-ratio: 16/10; width:100%; background:#000; overflow:hidden;
    }
    video{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1);
      filter:saturate(105%) contrast(105%) brightness(102%);
    }
    canvas.overlay{
      position:absolute; inset:0; width:100%; height:100%; pointer-events:none;
    }
    .statusbar{
      position:absolute; left:12px; bottom:12px; display:flex; gap:8px; align-items:center; padding:8px 12px; border-radius:999px;
      background:rgba(10,14,24,.6); border:1px solid rgba(255,255,255,.08); color:var(--muted); font-size:12px; backdrop-filter: blur(8px);
    }
    .dot{width:10px;height:10px;border-radius:999px;background:var(--warn); box-shadow:0 0 0 3px rgba(251,191,36,.25)}
    .dot.ok{background:var(--ok); box-shadow:0 0 0 3px rgba(74,222,128,.25)}
    .dot.err{background:var(--danger); box-shadow:0 0 0 3px rgba(255,92,122,.25)}
    .fps{font-variant-numeric: tabular-nums;}

    /* Right panel */
    .panel{display:grid; gap:16px}
    .card{
      border-radius: var(--radius);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h3{margin:0; padding:14px 16px; font-size:14px; letter-spacing:.3px; color:#e8ebf3; border-bottom:1px solid rgba(255,255,255,.07);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .card .content{padding:16px; display:grid; gap:12px}

    /* Gesture nav */
    .gnav{display:flex; gap:10px; flex-wrap:wrap}
    .gitem{
      flex:1 1 120px; min-width:120px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px; border-radius:12px; cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.08);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      transition:transform .12s ease, border-color .2s ease, background .2s ease;
    }
    .gitem.active{
      background:linear-gradient(180deg, rgba(0,255,163,.18), rgba(0,255,163,.05));
      border-color: rgba(0,255,163,.35);
      box-shadow: 0 8px 24px rgba(0,255,163,.15), inset 0 1px 0 rgba(255,255,255,.1);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size:12px; padding:2px 8px; border-radius:8px;
      background:linear-gradient(180deg, rgba(255,255,255,.15), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.2); color:#121726;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.5);
    }

    /* Buttons with dwell-activate */
    .btns{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px}
    @media (max-width:520px){ .btns{grid-template-columns:1fr 1fr} }
    .hbtn{
      position:relative; overflow:hidden; border-radius:14px; padding:14px; text-align:center; font-weight:700; cursor:pointer;
      border:1px solid rgba(255,255,255,.08);
      background:
       radial-gradient(160% 160% at 0% 0%, rgba(124,92,255,.18), transparent 40%),
       linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .hbtn:hover{transform:translateY(-1px)}
    .hbtn.active{
      border-color: rgba(0,255,163,.4);
      background:
        radial-gradient(160% 160% at 100% 0%, rgba(0,255,163,.25), transparent 40%),
        linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03));
      box-shadow:0 12px 30px rgba(0,255,163,.18);
    }
    .hbtn .sub{display:block; font-weight:600; font-size:12px; color:var(--muted); margin-top:4px}

    /* Sliders */
    .sliders{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width:700px){ .sliders{grid-template-columns:1fr} }
    .slider{
      position:relative; height:46px; border-radius:12px; padding: 10px 12px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      display:flex; align-items:center; gap:12px;
    }
    .track{position:relative; height:8px; flex:1; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden}
    .fill{position:absolute; inset:0 100% 0 0; background:linear-gradient(90deg, var(--accent2), var(--accent1));}
    .thumb{
      position:absolute; top:50%; transform:translate(-50%,-50%); width:20px; height:20px; border-radius:999px; background:#fff;
      box-shadow:0 4px 10px rgba(0,0,0,.3); border:2px solid #111827;
      transition: box-shadow .12s ease;
    }
    .slider:hover .thumb{box-shadow:0 6px 16px rgba(0,0,0,.4)}

    /* Drawing pad */
    .pad{
      position:relative; border-radius:14px; overflow:hidden; border:1px solid rgba(255,255,255,.09); background:#0b0f18;
      min-height:280px;
    }
    canvas#draw{display:block; width:100%; height:320px; background:
      linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));}
    .pad .tools{
      position:absolute; top:10px; right:10px; display:flex; gap:8px; z-index:5;
      background:rgba(10,14,24,.6); border:1px solid rgba(255,255,255,.1); padding:8px; border-radius:10px; backdrop-filter: blur(8px);
    }
    .tool{width:32px;height:32px;border-radius:9px;display:grid;place-items:center;cursor:pointer;
      background:linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.06)); border:1px solid rgba(255,255,255,.18)}
    .tool.active{outline:2px solid rgba(0,209,255,.6)}
    .badge{
      display:inline-flex; align-items:center; gap:6px; padding:8px 10px; border-radius:10px; font-size:12px; color:var(--muted);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08)
    }

    /* On-screen pointer */
    .cursor{
      position:absolute; width:28px; height:28px; border-radius:999px; pointer-events:none;
      border:2px solid rgba(255,255,255,.9); box-shadow: 0 0 0 6px rgba(124,92,255,.15);
      transform:translate(-50%,-50%); mix-blend-mode:difference; z-index:20;
    }
    .cursor .progress{
      position:absolute; inset:-4px; border-radius:999px; background:
      conic-gradient(var(--accent3) 0deg, rgba(255,255,255,.15) 0deg);
      mask: radial-gradient(circle, transparent 63%, black 64%);
      transition: background .08s linear;
    }
    .cursor.hidden{opacity:.25}

    .legend{display:grid; gap:8px; font-size:13px; color:var(--muted)}
    .legend li{display:flex; gap:10px; align-items:flex-start}
    .legend .dot{flex:0 0 10px; margin-top:5px}

    /* Error / fallback */
    .overlay-msg{
      position:absolute; inset:0; display:none; place-items:center; text-align:center; padding:24px; background:
      linear-gradient(180deg, rgba(10,14,24,.85), rgba(10,14,24,.6));
      border:1px dashed rgba(255,255,255,.12); border-radius: var(--radius); z-index:30;
    }
    .overlay-msg.show{display:grid}
    .overlay-msg .box{
      max-width:560px; padding:18px; border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08); box-shadow:var(--shadow)
    }

    footer{padding:14px clamp(12px, 3vw, 28px); color:var(--muted); font-size:12px; text-align:center; opacity:.9}

    /* Fancy little glow animation */
    @keyframes pulseGlow {
      0%{box-shadow: 0 10px 30px rgba(0,209,255,.20), 0 0 0 0 rgba(0,209,255,.35)}
      70%{box-shadow: 0 10px 30px rgba(0,209,255,.10), 0 0 0 16px rgba(0,209,255,0)}
      100%{box-shadow: 0 10px 30px rgba(0,209,255,.20), 0 0 0 0 rgba(0,209,255,.35)}
    }
    .pulse{animation:pulseGlow 2.6s infinite}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="nav">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <div style="font-size:14px; opacity:.9">Демо жестов</div>
            <div style="font-size:12px; color:var(--muted)">MediaPipe Hand Landmarker • WebGL • wasm</div>
          </div>
        </div>
        <div class="nav-right">
          <span class="pill" id="perm-pill">Статус камеры: <strong style="margin-left:6px" id="perm-state">запрос…</strong></span>
          <button class="btn secondary" id="toggle-cam">Отключить камеру</button>
          <button class="btn" id="toggle-mouse">Режим мыши</button>
        </div>
      </div>
    </header>

    <main>
      <div class="grid">
        <!-- LEFT: video + overlay and instructions -->
        <section class="stage">
          <div class="video-wrap" id="video-wrap">
            <video id="webcam" playsinline autoplay muted></video>
            <canvas class="overlay" id="overlay"></canvas>
            <div class="cursor" id="cursor">
              <div class="progress" id="cursorProgress"></div>
            </div>
            <div class="statusbar">
              <span class="dot" id="detect-dot" title="Отслеживание рук"></span>
              <span class="fps" id="fps">0 FPS</span>
              <span class="pill" id="hands-info">Руки: 0</span>
            </div>

            <div class="overlay-msg" id="fallback">
              <div class="box">
                <h2 style="margin:0 0 8px 0">Камера недоступна</h2>
                <p style="margin:0 0 10px 0; color:var(--muted)">Проверьте разрешения браузера или выберите «Режим мыши» для демонстрации возможностей без камеры.</p>
                <div style="display:flex; gap:10px; justify-content:center; margin-top:12px">
                  <button class="btn" id="ask-permission">Запросить доступ к камере</button>
                  <button class="btn secondary" id="enable-mouse-fallback">Включить режим мыши</button>
                </div>
                <ul class="legend" style="margin-top:14px; text-align:left">
                  <li><span class="dot ok"></span><span>Требуется HTTPS/localhost и современный браузер (Chrome/Edge/Safari/Firefox).</span></li>
                  <li><span class="dot warn"></span><span>Если ноутбук с несколькими камерами — выберите фронтальную в настройках браузера.</span></li>
                </ul>
              </div>
            </div>
          </div>

          <div class="card" style="margin:12px 12px 0">
            <h3>Инструкции по жестам</h3>
            <div class="content">
              <ul class="legend">
                <li><span class="dot ok"></span><span><b>Наведение</b>: наведите указательный палец на элемент — индикатор вокруг курсора заполнится и элемент активируется.</span></li>
                <li><span class="dot ok"></span><span><b>Пинч (щепотка)</b> (большой + указательный) — режим «схватить»: перемещайте палец вдоль слайдера для изменения значения или рисуйте на холсте.</span></li>
                <li><span class="dot ok"></span><span><b>Открытая ладонь</b> — открыть/подсветить меню навигации; <b>кулак</b> — свернуть.</span></li>
                <li><span class="dot ok"></span><span><b>Свайп</b> (быстрое движение вправо/влево) — переключение пунктов меню.</span></li>
                <li><span class="dot warn"></span><span>Подсказка: держите руку в центре кадра на расстоянии ~40–60 см от камеры. Картинка зеркальная — как в селфи-камере.</span></li>
              </ul>
            </div>
          </div>
        </section>

        <!-- RIGHT: interactive controls -->
        <aside class="panel">
          <div class="card">
            <h3>Навигация жестами</h3>
            <div class="content">
              <div class="gnav" id="gnav">
                <div class="gitem active" data-index="0"><span>Главная</span><span class="kbd">ладонь</span></div>
                <div class="gitem" data-index="1"><span>Галерея</span><span class="kbd">свайп ▶</span></div>
                <div class="gitem" data-index="2"><span>Плеер</span><span class="kbd">свайп ◀</span></div>
                <div class="gitem" data-index="3"><span>Настройки</span><span class="kbd">✊</span></div>
              </div>
              <div class="badge" id="nav-state"><span class="dot"></span><span>Управляйте: ладонь/свайп/кулак</span></div>
            </div>
          </div>

          <div class="card">
            <h3>Кнопки (hover-активация)</h3>
            <div class="content">
              <div class="btns" id="hoverBtns">
                <div class="hbtn" data-action="like">Нравится ❤️<span class="sub">Навести и удержать</span></div>
                <div class="hbtn" data-action="spark">Сверкание ✨<span class="sub">Навести и удержать</span></div>
                <div class="hbtn" data-action="boom">Бум 💥<span class="sub">Навести и удержать</span></div>
              </div>
              <div class="badge" id="btn-log"><span class="dot"></span><span>Ожидаю жест…</span></div>
            </div>
          </div>

          <div class="card">
            <h3>Слайдеры (пинч + движение)</h3>
            <div class="content sliders">
              <div class="slider" data-name="Яркость" id="sliderA">
                <span style="min-width:86px">Яркость</span>
                <div class="track"><div class="fill"></div><div class="thumb"></div></div>
                <span class="val">50%</span>
              </div>
              <div class="slider" data-name="Насыщенность" id="sliderB">
                <span style="min-width:86px">Насыщенность</span>
                <div class="track"><div class="fill"></div><div class="thumb"></div></div>
                <span class="val">50%</span>
              </div>
              <div class="badge"><span class="dot ok"></span><span>Сожмите большой и указательный пальцы, наведите на трек и перемещайте вдоль.</span></div>
            </div>
          </div>

          <div class="card">
            <h3>Холст для рисования (указательный + пинч)</h3>
            <div class="content">
              <div class="pad">
                <div class="tools">
                  <div class="tool active" data-tool="pen" title="Карандаш 🖊️">🖊️</div>
                  <div class="tool" data-tool="high" title="Маркер ✍️">✍️</div>
                  <div class="tool" data-tool="rainbow" title="Радуга 🌈">🌈</div>
                  <div class="tool" data-tool="erase" title="Ластик 🧽">🧽</div>
                  <div class="tool" data-tool="clear" title="Очистить 🗑️">🗑️</div>
                </div>
                <canvas id="draw" width="900" height="320"></canvas>
              </div>
              <div class="badge"><span class="dot ok"></span><span>Сожмите пальцы, чтобы рисовать. Разожмите — чтобы завершить штрих.</span></div>
            </div>
          </div>
        </aside>
      </div>
    </main>

    <footer>
      Этот пример работает целиком в браузере. Модель MediaPipe загружается из CDN (WebAssembly). Никаких данных с камеры не отправляется на сервер.
    </footer>
  </div>

  <!-- MediaPipe Tasks Vision: Hand Landmarker (wasm) -->
  <script type="module">
    // ============================ Импорт модели ============================
    import {
      HandLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    // ============================ DOM-ссылки ============================
    const video = document.getElementById("webcam");
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");
    const cursor = document.getElementById("cursor");
    const cursorProgress = document.getElementById("cursorProgress");
    const detectDot = document.getElementById("detect-dot");
    const fpsEl = document.getElementById("fps");
    const handsInfo = document.getElementById("hands-info");
    const fallback = document.getElementById("fallback");
    const askPermBtn = document.getElementById("ask-permission");
    const enableMouseFallback = document.getElementById("enable-mouse-fallback");
    const permState = document.getElementById("perm-state");
    const permPill = document.getElementById("perm-pill");
    const toggleCamBtn = document.getElementById("toggle-cam");
    const toggleMouseBtn = document.getElementById("toggle-mouse");

    const gnav = document.getElementById("gnav");
    const navState = document.getElementById("nav-state");
    const hoverBtns = document.getElementById("hoverBtns");
    const btnLog = document.getElementById("btn-log");

    const drawCanvas = document.getElementById("draw");
    const dctx = drawCanvas.getContext("2d", { willReadFrequently: false });

    // ============================ Глобальные состояния ============================
    let vision, handLandmarker, drawingUtils;
    let running = true;
    let mouseMode = false;          // fallback-режим
    let modelReady = false;
    let initialized = false;
    let videoStream = null;

    // размеры
    let vw = 1280, vh = 720;        // размер исходного видеопотока (обновится после play)
    let overlayRect = { left: 0, top: 0, width: 0, height: 0 };

    // Параметры жестов
    const SMOOTH = 0.35;            // сглаживание курсора (0..1), больше = плавнее
    const PINCH_TH = 0.05;          // порог щепотки (нормализованное расстояние)
    const DWELL_MS = 600;           // удержание для активации кнопок (мс)
    const SWIPE_VX = 1.2;           // порог скорости для свайпа (нормализ. ед/сек)
    const NEAR_PX = 60;             // "близость" курсора к контролу (px)

    // Курсор и истории
    let pointer = { x: 0.5, y: 0.5, px: 0, py: 0 }; // нормализованные 0..1
    let pointerPx = { x: 0, y: 0 };  // в пикселях, координаты overlay
    let vHist = [];                  // история скоростей для свайпа
    let lastT = 0;

    // Жесты
    let pinch = false;
    let fingersExtended = 0;
    let swipeCooldown = 0;

    // Состояние интерфейса
    let dwellTarget = null;
    let dwellStart = 0;
    let selectedNav = 0;

    // Слайдеры
    const sliders = [document.getElementById("sliderA"), document.getElementById("sliderB")];
    const sliderState = new Map(); // el -> {value:0..1}
    sliders.forEach((el) => sliderState.set(el, { value: .5 }));

    // Рисование
    let tool = "pen";
    let drawing = false;
    let hue = 0;

    // ============================ Утилиты ============================
    const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    function resizeOverlayToVideo(){
      const rect = document.getElementById("video-wrap").getBoundingClientRect();
      overlay.width = rect.width * devicePixelRatio;
      overlay.height = rect.height * devicePixelRatio;
      overlay.style.width = rect.width + "px";
      overlay.style.height = rect.height + "px";
      overlayRect = { left: rect.left + scrollX, top: rect.top + scrollY, width: rect.width, height: rect.height };
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      if(drawingUtils) drawingUtils = new DrawingUtils(ctx);
    }
    addEventListener("resize", resizeOverlayToVideo);
    addEventListener("orientationchange", resizeOverlayToVideo);

    function normToPx(nx, ny){
      // Видеопоток зеркалится по X (scaleX(-1)) -> инвертируем x
      const x = (1 - nx) * overlayRect.width;
      const y = ny * overlayRect.height;
      return { x, y };
    }

    function updateCursorVisual(progress=0){
      const deg = Math.round(clamp(progress,0,1)*360);
      cursorProgress.style.background = `conic-gradient(var(--accent3) ${deg}deg, rgba(255,255,255,.15) 0deg)`;
      cursor.style.left = `${pointerPx.x}px`;
      cursor.style.top = `${pointerPx.y}px`;
    }

    function setStatus(ok){
      detectDot.classList.toggle("ok", ok);
      detectDot.classList.toggle("err", !ok);
    }

    function setPermState(text, ok=false){
      permState.textContent = text;
      permPill.style.background = ok
        ? "linear-gradient(180deg, rgba(0,255,163,.22), rgba(0,255,163,.07))"
        : "linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02))";
      permPill.style.borderColor = ok ? "rgba(0,255,163,.35)" : "rgba(255,255,255,.08)";
    }

    // ============================ Камера ============================
    async function initCamera(){
      try{
        setPermState("запрос…");
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 1280 }, height: { ideal: 720 }
          },
          audio: false
        });
        video.srcObject = stream;
        videoStream = stream;
        await video.play();
        vw = video.videoWidth || 1280;
        vh = video.videoHeight || 720;
        setPermState("разрешено", true);
        fallback.classList.remove("show");
        resizeOverlayToVideo();
        return true;
      }catch(err){
        console.warn("Camera error:", err);
        setPermState("отклонено/ошибка");
        fallback.classList.add("show");
        return false;
      }
    }

    function stopCamera(){
      if(videoStream){
        for(const t of videoStream.getTracks()) t.stop();
        videoStream = null;
      }
      video.srcObject = null;
    }

    // ============================ Модель ============================
    async function initModel(){
      try{
        vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath:
              "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/hand_landmarker.task"
          },
          runningMode: "VIDEO",
          numHands: 2,
          minHandDetectionConfidence: 0.5,
          minHandPresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        drawingUtils = new DrawingUtils(ctx);
        modelReady = true;
      }catch(err){
        console.error("Model load error:", err);
        alert("Не удалось загрузить модель отслеживания рук. Проверьте подключение и попробуйте обновить страницу.");
        modelReady = false;
      }
    }

    // ============================ Жесты и логика ============================
    function getPinch(lms){
      // Точки: 4 (большой), 8 (указательный)
      const a = lms[4], b = lms[8];
      if(!a || !b) return {pinch:false, dist:1};
      const dx = a.x - b.x, dy = a.y - b.y;
      const dist = Math.hypot(dx,dy);
      return { pinch: dist < PINCH_TH, dist };
    }

    function countExtended(lms){
      // Проверка "кончик выше PIP" для каждой из 4 пальцев (кроме большого)
      // Индексы tip: 8,12,16,20; PIP: 6,10,14,18
      const pairs = [[8,6],[12,10],[16,14],[20,18]];
      let cnt = 0;
      for(const [tip,pip] of pairs){
        if(!lms[tip] || !lms[pip]) continue;
        // Из-за зеркала по X, но Y остаётся как есть: меньше = выше
        if(lms[tip].y < lms[pip].y) cnt++;
      }
      return cnt;
    }

    function updatePointerFromLandmarks(lms, dt){
      // Берём указательный (8) как "курсор"
      const tip = lms[8] || lms[9] || lms[0];
      if(!tip) return;

      // Сглаживание (EMA) в нормализованных координатах
      pointer.x = lerp(pointer.x, tip.x, SMOOTH);
      pointer.y = lerp(pointer.y, tip.y, SMOOTH);

      // Пиксельные координаты overlay
      const {x, y} = normToPx(pointer.x, pointer.y);
      pointerPx.x = x;
      pointerPx.y = y;

      // скорость по X для свайпа (нормализованная/сек)
      const vx = ((pointer.x - pointer.px) / Math.max(dt, 0.016));
      vHist.push(vx);
      if(vHist.length > 6) vHist.shift();
      pointer.px = pointer.x; pointer.py = pointer.y;
    }

    function detectSwipe(){
      if(swipeCooldown > 0) return 0;
      const avgVx = vHist.reduce((a,b)=>a+b,0)/Math.max(1,vHist.length);
      if(avgVx > SWIPE_VX){ swipeCooldown = 12; return +1; }
      if(avgVx < -SWIPE_VX){ swipeCooldown = 12; return -1; }
      return 0;
    }

    function setNav(index){
      selectedNav = (index+4)%4;
      [...gnav.children].forEach((el,i)=> el.classList.toggle("active", i===selectedNav));
      const dot = navState.querySelector(".dot");
      dot.classList.add("ok");
      navState.lastElementChild.textContent = `Текущий раздел: ${gnav.children[selectedNav].firstChild.textContent}`;
    }

    function processNavGestures(){
      // ладонь открыта => подсветить меню
      // кулак => свернуть (снять активные подсветки)
      if(fingersExtended >= 4){
        gnav.classList.add("pulse");
      }else{
        gnav.classList.remove("pulse");
      }
      const sw = detectSwipe();
      if(sw === 1) setNav(selectedNav+1);
      else if(sw === -1) setNav(selectedNav-1);
    }

    function rectOf(el){
      const r = el.getBoundingClientRect();
      return { x:r.left+scrollX, y:r.top+scrollY, w:r.width, h:r.height };
    }

    function inside(px, py, r, margin=0){
      return (px >= r.x-margin && px <= r.x+r.w+margin && py >= r.y-margin && py <= r.y+r.h+margin);
    }

    function updateDwellButtons(now){
      const btns = [...hoverBtns.children];
      let target = null;
      for(const b of btns){
        const r = rectOf(b);
        if(inside(pointerPx.x, pointerPx.y, r, 0)){
          target = b; break;
        }
      }
      if(target !== dwellTarget){
        dwellTarget = target;
        dwellStart = now;
        updateCursorVisual(0);
      }else if(dwellTarget){
        const p = clamp((now - dwellStart)/DWELL_MS, 0, 1);
        updateCursorVisual(p);
        if(p >= 1){
          dwellTarget.classList.toggle("active");
          const action = dwellTarget.dataset.action;
          logBtn(`Кнопка «${action}» активирована`);
          dwellStart = now + 1e6; // простая защита от повторного срабатывания
        }
      }else{
        updateCursorVisual(0);
      }
    }

    function logBtn(text){
      btnLog.lastElementChild.textContent = text;
      const dot = btnLog.querySelector(".dot");
      dot.classList.add("ok");
      setTimeout(()=>dot.classList.remove("ok"), 600);
    }

    function valueFromTrack(x, trackEl){
      const r = rectOf(trackEl);
      const v = clamp((x - r.x) / Math.max(1, r.w), 0, 1);
      return v;
    }

    function nearestSlider(px, py){
      let minD = Infinity, best = null;
      for(const el of sliders){
        const r = rectOf(el);
        // расстояние до центра трека
        const track = el.querySelector(".track");
        const tr = rectOf(track);
        const cx = clamp(px, tr.x, tr.x+tr.w);
        const cy = tr.y + tr.h/2;
        const d = Math.hypot(px-cx, py-cy);
        if(d < minD){ minD = d; best = {el, track, tr}; }
      }
      return (minD < NEAR_PX) ? best : null;
    }

    function applySlider(el, v){
      const st = sliderState.get(el);
      st.value = v;
      const track = el.querySelector(".track");
      const fill = track.querySelector(".fill");
      const thumb = track.querySelector(".thumb");
      const val = el.querySelector(".val");
      fill.style.insetInlineEnd = `${Math.round((1-v)*100)}%`;
      const tr = track.getBoundingClientRect();
      thumb.style.left = `${v*tr.width}px`;
      val.textContent = `${Math.round(v*100)}%`;

      // побочные эффекты: на лету меняем фон демо
      if(el.id === "sliderA"){
        // яркость: от 0.8 до 1.2
        const br = 0.8 + v*0.4;
        document.body.style.filter = `brightness(${br}) saturate(${0.8 + sliderState.get(sliders[1]).value*0.8})`;
      }
    }

    function drawStroke(prev, curr, width, color, erase=false){
      dctx.lineJoin = dctx.lineCap = "round";
      dctx.globalCompositeOperation = erase ? "destination-out" : "source-over";
      dctx.strokeStyle = color;
      dctx.lineWidth = width;
      dctx.beginPath();
      dctx.moveTo(prev.x, prev.y);
      dctx.lineTo(curr.x, curr.y);
      dctx.stroke();
      dctx.globalCompositeOperation = "source-over";
    }

    function processDrawing(){
      // Координаты курсора относительно canvas рисования
      const r = rectOf(drawCanvas);
      const x = clamp(pointerPx.x - r.x, 0, r.w);
      const y = clamp(pointerPx.y - r.y, 0, r.h);

      // Начать/закончить рисование по пинчу
      if(pinch && inside(pointerPx.x, pointerPx.y, r, 0)){
        if(!drawing){
          drawing = true;
          dctx.beginPath();
        }else{
          // непрерывный штрих
          const prev = processDrawing.prev || { x, y };
          // выбор инструмента
          let width = 4, color = "#fff", erase=false;
          if(tool === "pen"){ width = 4; color = "#fff"; }
          else if(tool === "high"){ width = 10; color = "rgba(124,92,255,.8)"; }
          else if(tool === "rainbow"){ width = 8; hue = (hue+4)%360; color = `hsl(${hue} 100% 60%)`; }
          else if(tool === "erase"){ width = 24; erase = true; }

          drawStroke(prev, {x,y}, width, color, erase);
          processDrawing.prev = { x, y };
        }
      }else{
        drawing = false;
        processDrawing.prev = null;
      }
    }

    function setTool(t){
      tool = t;
      document.querySelectorAll(".tool").forEach(el=> el.classList.toggle("active", el.dataset.tool===t));
      if(t === "clear"){
        dctx.clearRect(0,0,drawCanvas.width, drawCanvas.height);
        setTool("pen");
      }
    }
    document.querySelectorAll(".tool").forEach(el=>{
      el.addEventListener("click", ()=> setTool(el.dataset.tool));
    });

    // ============================ Главный цикл ============================
    let frames = 0, lastFpsT = performance.now();

    async function tick(now){
      if(!running){ requestAnimationFrame(tick); return; }
      const dt = Math.min(0.1, (now - (lastT || now))/1000);
      lastT = now;
      if(swipeCooldown>0) swipeCooldown--;

      // Очистка оверлея
      ctx.clearRect(0,0,overlay.width, overlay.height);

      let hands = 0;

      if(modelReady && (video.readyState >= 2) && !mouseMode){
        const res = handLandmarker.detectForVideo(video, now);
        hands = res?.landmarks?.length || 0;
        if(hands > 0){
          setStatus(true);
          handsInfo.textContent = `Руки: ${hands}`;
          // Рисуем и берём первую руку как управляющую
          const lms = res.landmarks[0];
          drawingUtils.drawConnectors(lms, HandLandmarker.HAND_CONNECTIONS, { color: "#00d1ff", lineWidth: 3 });
          drawingUtils.drawLandmarks(lms, { color: "#00ffa3", lineWidth: 1, radius: 3 });

          // Обновление курсора
          updatePointerFromLandmarks(lms, dt);

          // Детекция пинча/кол-ва пальцев
          const {pinch: p} = getPinch(lms);
          pinch = p;
          fingersExtended = countExtended(lms);
        }else{
          setStatus(false);
          handsInfo.textContent = `Руки: 0`;
        }
      }

      // Визуал курсора
      updateCursorVisual(dwellTarget ? clamp((now-dwellStart)/DWELL_MS,0,1) : 0);

      // Интерфейс
      processNavGestures();
      updateDwellButtons(now);

      // Работать со слайдерами (только при пинче)
      if(pinch){
        const near = nearestSlider(pointerPx.x, pointerPx.y);
        if(near){
          const v = valueFromTrack(pointerPx.x, near.track);
          applySlider(near.el, v);
        }
      }

      // Рисование
      processDrawing();

      // Ставим курсор поверх, скрываем при мышином режиме если не двигается
      cursor.classList.toggle("hidden", mouseMode && !mouseMovedRecently());

      // FPS
      frames++;
      if(now - lastFpsT >= 500){
        const fps = Math.round(frames * 1000 / (now - lastFpsT));
        fpsEl.textContent = fps + " FPS";
        lastFpsT = now; frames = 0;
      }

      requestAnimationFrame(tick);
    }

    // ============================ Мышиный режим (fallback) ============================
    let mouseLastMove = 0;
    function mouseMovedRecently(){ return performance.now() - mouseLastMove < 1500; }
    function enableMouseMode(on){
      mouseMode = on;
      toggleMouseBtn.textContent = on ? "Камера + мышь" : "Режим мыши";
      document.body.classList.toggle("mouse-on", on);
    }
    addEventListener("mousemove", (e)=>{
      if(!mouseMode) return;
      mouseLastMove = performance.now();
      // нормализуем в координатах overlay
      const nx = clamp((e.clientX - overlayRect.left) / Math.max(1, overlayRect.width), 0, 1);
      const ny = clamp((e.clientY - overlayRect.top) / Math.max(1, overlayRect.height), 0, 1);
      pointer.x = nx; pointer.y = ny;
      const p = normToPx(nx, ny);
      pointerPx = p;
      updateCursorVisual(0);
    });
    addEventListener("mousedown", ()=> { if(mouseMode){ pinch = true; } });
    addEventListener("mouseup", ()=> { if(mouseMode){ pinch = false; drawing = false; } });

    // ============================ Системные обработчики ============================
    toggleCamBtn.addEventListener("click", ()=>{
      if(videoStream){ stopCamera(); toggleCamBtn.textContent = "Включить камеру"; }
      else { initCamera(); toggleCamBtn.textContent = "Отключить камеру"; }
    });
    toggleMouseBtn.addEventListener("click", ()=> enableMouseMode(!mouseMode));
    askPermBtn.addEventListener("click", initCamera);
    enableMouseFallback.addEventListener("click", ()=> { enableMouseMode(true); fallback.classList.remove("show"); });

    // Клики по навигации
    gnav.addEventListener("click", (e)=>{
      const item = e.target.closest(".gitem");
      if(!item) return;
      setNav(parseInt(item.dataset.index,10));
    });

    // Инициализация слайдеров
    sliders.forEach(el=> applySlider(el, sliderState.get(el).value));

    // Адаптация размера холста под CSS-размер
    function resizeDrawCanvas(){
      const r = drawCanvas.getBoundingClientRect();
      drawCanvas.width = Math.floor(r.width * devicePixelRatio);
      drawCanvas.height = Math.floor(r.height * devicePixelRatio);
      // удобно рисовать в CSS-px, но для простоты оставим масштаб 1:1 через transform
      dctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    resizeDrawCanvas();
    addEventListener("resize", resizeDrawCanvas);

    // ============================ Старт ============================
    (async function start(){
      // Если нет камеры — не падаем, предложим fallback
      await initModel();
      const camOk = await initCamera();
      if(!camOk){
        fallback.classList.add("show");
      }
      resizeOverlayToVideo();
      initialized = true;
      requestAnimationFrame(tick);
    })();
  </script>

  <!-- Небольшой скрипт без модулей: украшения и защитные проверки -->
  <script>
    // Безопасности ради – проверим поддержку API
    (function(){
      const ok = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      if(!ok){
        const fb = document.getElementById("fallback");
        if(fb){ fb.classList.add("show"); fb.querySelector(".box p").textContent = "Ваш браузер не поддерживает доступ к камере. Используйте современный Chrome/Edge/Safari/Firefox или включите режим мыши."; }
      }
    })();
  </script>
</body>
</html>
