<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Hand-Tracked UI ‚Äî MediaPipe + Gesture Controls (Single File)</title>
  <!-- Google Font (CDN) -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    /* ===========================
       GLOBAL / RESET / THEME
       =========================== */
    :root{
      --bg: 220 18% 8%;
      --card: 226 18% 14%;
      --muted: 220 6% 60%;
      --text: 210 20% 98%;
      --accent: 267 83% 62%;
      --accent-2: 197 95% 52%;
      --ok: 152 70% 45%;
      --warn: 43 95% 55%;
      --err: 0 85% 55%;
      --radius: 20px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --glass: linear-gradient(180deg, hsla(var(--card)/.9), hsla(var(--card)/.7));
      --ring: 0 0 0 3px hsl(var(--accent)/.45), 0 10px 30px rgba(0,0,0,.35);
      --hue: 0; /* Controlled by slider to subtly color accents */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      color:hsl(var(--text));
      background:
        radial-gradient(60vmax 60vmax at 10% -10%, hsl(calc(210+var(--hue)) 60% 12%/.8), transparent 60%),
        radial-gradient(60vmax 60vmax at 110% 10%, hsl(calc(280+var(--hue)) 70% 14%/.7), transparent 60%),
        hsl(var(--bg));
      overflow-x:hidden;
    }
    a{color:inherit}

    /* ===========================
       LAYOUT
       =========================== */
    .app{
      display:grid;
      grid-template-columns: minmax(280px, 1.2fr) minmax(320px, .9fr);
      gap:24px;
      padding: clamp(14px, 4vw, 28px);
      min-height:100%;
    }
    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
    }

    /* Header / Status Bar */
    .topbar{
      grid-column: 1 / -1;
      display:flex; align-items:center; justify-content:space-between;
      padding: 14px 18px;
      background: var(--glass);
      border:1px solid hsla(0,0%,100%,.06);
      border-radius: calc(var(--radius) - 8px);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex; align-items:center; gap:12px; font-weight:800; letter-spacing:.3px;
    }
    .brand .dot{
      width:12px; height:12px; border-radius:999px;
      background: conic-gradient(from 0deg, hsl(var(--accent)), hsl(var(--accent-2)));
      box-shadow:0 0 10px hsl(var(--accent)/.8), inset 0 0 8px hsl(var(--accent-2)/.6);
    }
    .status{
      display:flex; gap:14px; align-items:center; font-size:13px; color:hsl(var(--muted));
      flex-wrap:wrap;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      background: hsla(0,0%,100%,.06);
      border: 1px solid hsla(0,0%,100%,.08);
    }
    .pill .led{
      width:10px; height:10px; border-radius:50%;
      background:hsl(var(--warn));
      box-shadow:0 0 0 3px hsl(43 95% 55%/.15);
    }
    .pill.ok .led{ background:hsl(var(--ok)); box-shadow:0 0 0 3px hsl(152 70% 45%/.15); }
    .pill.err .led{ background:hsl(var(--err)); box-shadow:0 0 0 3px hsl(0 85% 55%/.15); }
    .pill .val{ color:hsl(var(--text)); font-weight:600}

    /* ===========================
       CAMERA PANEL
       =========================== */
    .camera-card{
      position:relative; overflow:hidden; border-radius: var(--radius);
      background: #000; box-shadow: var(--shadow);
      border:1px solid hsla(0,0%,100%,.06);
      min-height: 420px;
    }
    .video-wrap{
      position:relative; width:100%; padding-top: 56.25%; /* 16:9 aspect */
      background: #0b0f16;
    }
    video#video, canvas#overlay{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit: cover;
      border-radius: inherit;
    }
    /* Mirror the camera for a natural interaction. We counter-mirror coordinates in JS. */
    video#video{ transform: scaleX(-1); filter: contrast(1.05) saturate(1.15) brightness(1.02); }
    canvas#overlay{ pointer-events:none; }

    /* Visual outline that lights up when hands are detected */
    .camera-card.detecting{
      outline: 3px solid hsl(var(--accent)/.55);
      box-shadow: 0 0 0 6px hsl(var(--accent)/.18), var(--shadow);
      transition: outline 180ms ease, box-shadow 180ms ease;
    }

    /* On-screen help / errors */
    .banner{
      position:absolute; left:12px; bottom:12px;
      background: hsla(0,0%,0%,.55); color:#fff; padding:10px 12px; font-size:13px;
      border-radius: 12px; backdrop-filter: blur(6px);
      border:1px solid hsla(0,0%,100%,.08);
      max-width:min(560px, 96%);
    }
    .banner strong{ color: hsl(var(--accent-2)); }
    .banner.error{ background: hsla(0,85%,40%,.40); border-color: hsla(0,0%,100%,.15); }

    /* ‚ÄúHand cursor‚Äù rendered in DOM for UI interactions */
    .cursor{
      --size: 24px;
      position:fixed; left:0; top:0; translate: -50% -50%;
      width:var(--size); height:var(--size); border-radius:999px;
      border:2px solid hsl(var(--accent));
      box-shadow: var(--ring);
      pointer-events:none;
      z-index: 50;
      opacity:0; transition: opacity .2s ease, transform .08s linear;
      transform: scale(1);
    }
    .cursor.active{ opacity:1; }
    .cursor.click{ transform: scale(.8); box-shadow: 0 0 0 6px hsl(var(--accent)/.35), var(--ring);}
    .cursor .pulse{
      position:absolute; inset:-8px;
      border-radius:inherit; border:2px dashed hsl(var(--accent)/.6);
      animation: pulse 1.8s linear infinite;
    }
    @keyframes pulse{
      0%{ opacity:.8; transform:scale(.8) rotate(0deg) }
      100%{ opacity:0; transform:scale(1.6) rotate(180deg) }
    }

    /* ===========================
       UI PANEL (Interactive elements)
       =========================== */
    .ui{
      display:flex; flex-direction:column; gap:18px;
    }
    .card{
      background: var(--glass);
      border:1px solid hsla(0,0%,100%,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2.4vw, 18px);
    }
    .card h3{ margin:0 0 8px; letter-spacing:.2px }
    .muted{ color:hsl(var(--muted)); font-size:14px }

    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center }

    .btn{
      appearance:none; border:1px solid hsla(0,0%,100%,.12);
      padding:12px 14px; border-radius:14px; background: hsla(0,0%,100%,.06);
      color:#fff; font-weight:600; cursor:pointer; transition: transform .12s ease, background .2s ease, border-color .2s ease;
      position:relative; overflow:hidden;
    }
    .btn:hover{ transform: translateY(-1px); background: hsla(0,0%,100%,.12) }
    .btn:active{ transform: translateY(0) scale(.98) }
    .btn.primary{
      background: linear-gradient(135deg, hsl(calc(267+var(--hue)) 83% 62%), hsl(calc(197+var(--hue)) 95% 52%));
      border: none;
    }

    /* Custom slider */
    .slider-wrap{ width:100%; }
    input[type="range"]{
      -webkit-appearance:none; width:100%; height: 16px; background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 10px; background: linear-gradient(90deg, hsl(calc(200+var(--hue)) 80% 60%), hsl(calc(320+var(--hue)) 80% 60%));
      border-radius:999px; border:1px solid hsla(0,0%,100%,.1);
      box-shadow: inset 0 1px 6px rgba(0,0,0,.35);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; width:22px; height:22px; border-radius:50%;
      background:#fff; border: 3px solid hsl(calc(270+var(--hue)) 90% 60%);
      margin-top: -6px; box-shadow:0 4px 12px rgba(0,0,0,.4);
    }
    input[type="range"]::-moz-range-track{ background: transparent; }
    input[type="range"]::-moz-range-thumb{ width:22px; height:22px; border-radius:50%; background:#fff; border:3px solid hsl(calc(270+var(--hue)) 90% 60%); }

    /* Swipe carousel */
    .carousel{
      position:relative; overflow:hidden; border-radius:16px; border:1px solid hsla(0,0%,100%,.06);
    }
    .slides{ display:flex; transition: transform .45s cubic-bezier(.22,1,.36,1); will-change: transform; }
    .slide{
      min-width:100%; padding:18px; display:grid; place-items:center;
      background: radial-gradient(80% 80% at 50% 0%, hsl(calc(240+var(--hue)) 40% 18%), hsl(calc(190+var(--hue)) 40% 14%));
    }
    .slide h4{ margin:0 0 6px}
    .slide p{ margin:0; color:hsl(var(--muted)) }
    .dots{ display:flex; gap:6px; justify-content:center; margin-top:10px }
    .dot{ width:10px; height:10px; border-radius:999px; background: hsla(0,0%,100%,.22); border:none }
    .dot.active{ background: hsl(var(--accent)); }

    /* Hover highlight when the cursor is over a gesturable element */
    [data-gesturable]{ position:relative; }
    [data-gesturable].hover::after{
      content:""; position:absolute; inset:0; border-radius: inherit;
      outline:2px dashed hsl(var(--accent)/.7); outline-offset: -6px; pointer-events:none;
      animation: hoverGlow 1s ease-in-out infinite alternate;
    }
    @keyframes hoverGlow{
      from{ box-shadow: 0 0 0 0 hsl(var(--accent)/.0); }
      to{ box-shadow: 0 0 30px 0 hsl(var(--accent)/.25); }
    }

    /* Accessibility: reduce motion */
    @media (prefers-reduced-motion: reduce){
      .cursor .pulse{ display:none }
      .slides{ transition: none }
      .btn{ transition:none }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- ===========================
         TOP BAR / STATUS
         =========================== -->
    <div class="topbar">
      <div class="brand">
        <span class="dot"></span>
        <div>Hand-Tracked UI</div>
      </div>
      <div class="status" id="status">
        <span class="pill" id="permPill"><span class="led" aria-hidden="true"></span> Camera: <span class="val">Requesting‚Ä¶</span></span>
        <span class="pill" id="handsPill"><span class="led" aria-hidden="true"></span> Hands: <span class="val">0</span></span>
        <span class="pill" id="gestPill"><span class="led" aria-hidden="true"></span> Gesture: <span class="val">Idle</span></span>
      </div>
    </div>

    <!-- ===========================
         CAMERA / LANDMARK OVERLAY
         =========================== -->
    <section class="camera-card" id="camCard" data-gesturable>
      <div class="video-wrap" id="videoWrap">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="banner" id="hint">
        <strong>How to use:</strong> Point your index finger to move the on-screen cursor. <strong>Pinch (thumb + index)</strong> to click. <strong>Swipe</strong> with your index finger over the carousel to change slides.
      </div>
      <div class="banner error" id="errorBanner" style="display:none"></div>
    </section>

    <!-- ===========================
         INTERACTIVE UI
         =========================== -->
    <section class="ui">
      <div class="card" data-gesturable>
        <h3>Controls</h3>
        <p class="muted">These buttons and the slider respond to <strong>pinch clicks</strong> and <strong>drag</strong> while pinched.</p>
        <div class="row">
          <button class="btn primary" id="btnHello" data-gesturable>‚ú® Say Hello</button>
          <button class="btn" id="btnTheme" data-gesturable>üåà Shuffle Theme</button>
          <button class="btn" id="btnConfetti" data-gesturable>üéâ Confetti</button>
        </div>
        <div class="row slider-wrap" style="margin-top:12px">
          <label for="hue" class="muted" style="min-width:120px">Accent Hue</label>
          <input type="range" min="0" max="120" value="0" id="hue" data-gesturable />
        </div>
      </div>

      <div class="card carousel" id="carousel" data-gesturable>
        <div class="slides" id="slides">
          <div class="slide" aria-label="Slide 1">
            <div>
              <h4>Swipe Left/Right</h4>
              <p>Use your index finger to swipe over this area.</p>
            </div>
          </div>
          <div class="slide" aria-label="Slide 2">
            <div>
              <h4>Pinch to Click</h4>
              <p>Try clicking the dots or buttons with a pinch.</p>
            </div>
          </div>
          <div class="slide" aria-label="Slide 3">
            <div>
              <h4>Gesture Feedback</h4>
              <p>Watch the status pills update in real time.</p>
            </div>
          </div>
        </div>
        <div class="dots" id="dots" aria-label="Carousel Pagination">
          <button class="dot" aria-label="Go to slide 1" data-gesturable></button>
          <button class="dot" aria-label="Go to slide 2" data-gesturable></button>
          <button class="dot" aria-label="Go to slide 3" data-gesturable></button>
        </div>
      </div>

      <div class="card" data-gesturable>
        <h3>About</h3>
        <p class="muted">
          This demo uses <strong>MediaPipe Hands</strong> (via CDN) for landmark detection. All UI logic runs client-side.
          If your browser blocks the camera, use the ‚ÄúRetry Camera‚Äù button that appears below.
        </p>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="retryBtn" data-gesturable>üîÅ Retry Camera</button>
          <button class="btn" id="toggleGestures" data-gesturable>üñêÔ∏è Toggle Gestures</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Cursor rendered above everything for clarity -->
  <div class="cursor" id="cursor" aria-hidden="true">
    <div class="pulse" aria-hidden="true"></div>
  </div>

  <!-- ===========================
       LIBRARIES (CDN)
       MediaPipe Hands + camera/drawing utils
       =========================== -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /* ============================================================
       Hand-Tracked UI ‚Äî Full Inline JS (detailed comments included)
       ============================================================ */

    // -----------------------------
    // DOM helpers
    // -----------------------------
    const $ = sel => document.querySelector(sel);
    const $$ = sel => [...document.querySelectorAll(sel)];

    const video = $('#video');
    const overlay = $('#overlay');
    const ctx = overlay.getContext('2d');
    const camCard = $('#camCard');
    const videoWrap = $('#videoWrap');
    const errorBanner = $('#errorBanner');
    const hint = $('#hint');
    const cursor = $('#cursor');

    const permPill = $('#permPill');
    const handsPill = $('#handsPill');
    const gestPill = $('#gestPill');

    const btnHello = $('#btnHello');
    const btnTheme = $('#btnTheme');
    const btnConfetti = $('#btnConfetti');
    const hueSlider = $('#hue');
    const retryBtn = $('#retryBtn');
    const toggleGesturesBtn = $('#toggleGestures');

    const slides = $('#slides');
    const dots = $$('#dots .dot');
    let activeSlide = 0;

    // -----------------------------
    // Feature detection & errors
    // -----------------------------
    function hasGetUserMedia(){
      return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }
    function hasWebGL(){
      try {
        const c = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (c.getContext('webgl') || c.getContext('experimental-webgl')));
      } catch { return false; }
    }
    function showError(msg){
      errorBanner.style.display = 'block';
      errorBanner.textContent = msg;
      permPill.classList.remove('ok');
      permPill.classList.add('err');
      permPill.querySelector('.val').textContent = 'Error';
    }

    if(!hasGetUserMedia()){
      showError('Your browser does not support camera access (getUserMedia). Please use a modern browser over HTTPS.');
    }
    if(!hasWebGL()){
      showError('WebGL is not available. MediaPipe requires WebGL to run on the web.');
    }

    // -----------------------------
    // MediaPipe Hands setup
    // -----------------------------
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    // Tunable parameters (balanced for browsers & laptops)
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,             // 0=lite, 1=full
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.5
    });

    // Landmark connections from drawing_utils
    const {drawConnectors, drawLandmarks} = window;

    let stream = null;
    let running = false;
    let lastFrameTime = 0;

    // -----------------------------
    // Camera start / retry
    // -----------------------------
    async function startCamera(){
      try{
        permPill.querySelector('.val').textContent = 'Requesting‚Ä¶';
        permPill.classList.remove('ok','err');

        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: {ideal: 1280},
            height:{ideal: 720},
            facingMode: 'user'
          },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        // Resize the overlay to match the displayed video
        resizeOverlay();

        // Update status pill
        permPill.classList.add('ok');
        permPill.querySelector('.val').textContent = 'Granted';

        errorBanner.style.display = 'none';
        hint.style.display = '';

        running = true;
        requestAnimationFrame(loop);
      }catch(err){
        console.error(err);
        let msg = 'Camera access was blocked. Please allow camera permissions and use HTTPS.';
        if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
          msg += ' Tip: open this page via https:// or on localhost.';
        }
        showError(msg + ` (${err.name || 'Error'})`);
        hint.style.display = 'none';
      }
    }

    function stopCamera(){
      if(stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      running = false;
    }

    retryBtn.addEventListener('click', startCamera);

    // -----------------------------
    // Main processing loop
    // Sends frames to MediaPipe and draws results
    // -----------------------------
    async function loop(ts){
      if(!running){ return; }

      // Throttle to ~30fps for consistency
      if(ts - lastFrameTime < 33){
        return requestAnimationFrame(loop);
      }
      lastFrameTime = ts;

      if(video.readyState >= 2){
        await hands.send({image: video}); // onResults() will be called
      }
      requestAnimationFrame(loop);
    }

    // -----------------------------
    // Rendering helpers
    // -----------------------------
    function resizeOverlay(){
      // Match overlay canvas to rendered <video> size on screen
      const rect = video.getBoundingClientRect();
      overlay.width = rect.width * devicePixelRatio;
      overlay.height = rect.height * devicePixelRatio;
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener('resize', resizeOverlay);

    // -----------------------------
    // Gesture state & utilities
    // -----------------------------
    const pointer = { x: window.innerWidth/2, y: window.innerHeight/2, visible:false };
    let lastPointer = { x: pointer.x, y: pointer.y, t: performance.now() };
    let pinchActive = false;
    let pinchJustStarted = false;
    let gestureEnabled = true;

    // Keep a rolling history of index tip positions to detect swipes
    const posHistory = [];
    const MAX_HISTORY = 8;

    function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function setCursor(x,y,active){
      pointer.x = lerp(pointer.x, x, 0.35); // smooth the motion
      pointer.y = lerp(pointer.y, y, 0.35);
      cursor.style.left = pointer.x + 'px';
      cursor.style.top  = pointer.y + 'px';
      cursor.classList.toggle('active', active);
    }

    // Determine simple finger states (heuristic):
    // pointing: index extended, others mostly curled
    function isPointing(lm){
      const wrist = lm[0];
      const iTip = lm[8], iPip = lm[6];
      const mTip = lm[12], rTip = lm[16], pTip = lm[20];

      // A very simple heuristic: index tip is notably above its PIP,
      // and other tips are below their PIPs (for a front-facing camera).
      const indexExtended = iTip.y < iPip.y - 0.02;
      const othersCurled  = (mTip.y > lm[10].y - 0.01) && (rTip.y > lm[14].y - 0.01) && (pTip.y > lm[18].y - 0.01);

      return indexExtended && othersCurled;
    }

    // Pinch detection (thumb tip vs index tip)
    function detectPinch(lm){
      const thumbTip = lm[4];
      const indexTip = lm[8];
      // Normalize threshold by hand size (distance wrist->middle MCP)
      const handScale = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
      const d = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
      return d < Math.max(0.03, handScale * 0.37);
    }

    // Map normalized (0..1) MediaPipe coords to viewport space, compensating for mirrored video
    function toViewportCoords(nx, ny){
      // Find where the video is on screen
      const rect = video.getBoundingClientRect();
      const x = rect.left + (1 - nx) * rect.width; // mirrored horizontally
      const y = rect.top + ny * rect.height;
      return { x, y };
    }

    // Swipe detection using recent index-tip positions (viewport space)
    let lastSwipeTime = 0;
    function maybeDetectSwipe(){
      if(posHistory.length < 4) return null;
      const a = posHistory[0];
      const b = posHistory[posHistory.length - 1];
      const dt = (b.t - a.t) || 1;
      const vx = (b.x - a.x) / dt; // px per ms
      const vy = (b.y - a.y) / dt;

      const speed = Math.hypot(vx, vy);
      const sinceLast = performance.now() - lastSwipeTime;

      // Require sufficient horizontal velocity, moderate speed, and cooldown
      if(Math.abs(vx) > 0.6 && speed > 0.6 && sinceLast > 400){
        lastSwipeTime = performance.now();
        return vx > 0 ? 'right' : 'left';
      }
      return null;
    }

    // -----------------------------
    // Hit-testing & element interactions
    // -----------------------------
    let draggingSlider = null;

    function getTopGesturableElementAt(x,y){
      const el = document.elementFromPoint(x,y);
      if(!el) return null;
      // Climb up the DOM to find something marked data-gesturable
      return el.closest('[data-gesturable]') || null;
    }

    function setHover(el){
      // Remove previous hover states
      $$('[data-gesturable].hover').forEach(n => n.classList.remove('hover'));
      if(el) el.classList.add('hover');
    }

    function pinchClick(el){
      if(!el) return;
      // Visual ripple
      const ripple = document.createElement('span');
      ripple.style.position='absolute';
      ripple.style.left = (pointer.x - el.getBoundingClientRect().left - 10)+'px';
      ripple.style.top  = (pointer.y - el.getBoundingClientRect().top  - 10)+'px';
      ripple.style.width='20px'; ripple.style.height='20px';
      ripple.style.borderRadius='999px';
      ripple.style.background='rgba(255,255,255,.45)';
      ripple.style.boxShadow='0 0 0 8px rgba(255,255,255,.08)';
      ripple.style.pointerEvents='none';
      el.appendChild(ripple);
      setTimeout(()=> ripple.remove(), 350);

      // Simulate a click
      if(el.tagName === 'INPUT' && el.type === 'range'){
        // Slider will be manipulated continuously during drag
      }else{
        el.click?.();
      }
    }

    function updateSliderAtPointer(slider){
      const rect = slider.getBoundingClientRect();
      const t = Math.min(1, Math.max(0, (pointer.x - rect.left) / rect.width));
      const val = +slider.min + t * (+slider.max - +slider.min);
      slider.value = Math.round(val);
      slider.dispatchEvent(new Event('input', {bubbles:true}));
    }

    // -----------------------------
    // UI logic (buttons, slider, carousel)
    // -----------------------------
    btnHello.addEventListener('click', () => {
      toast('üëã Hello from your hand-tracked UI!');
    });
    btnTheme.addEventListener('click', () => {
      const newHue = Math.floor(Math.random()*120);
      hueSlider.value = newHue;
      document.documentElement.style.setProperty('--hue', newHue);
      toast('üé® Theme shuffled');
    });
    btnConfetti.addEventListener('click', doConfetti);

    hueSlider.addEventListener('input', (e)=>{
      document.documentElement.style.setProperty('--hue', e.target.value);
    });

    toggleGesturesBtn.addEventListener('click', ()=>{
      gestureEnabled = !gestureEnabled;
      gestPill.querySelector('.val').textContent = gestureEnabled ? 'On' : 'Off';
      toggleGesturesBtn.textContent = gestureEnabled ? 'üñêÔ∏è Toggle Gestures' : 'üñêÔ∏è Enable Gestures';
      toast(`Gestures ${gestureEnabled ? 'enabled' : 'disabled'}`);
    });

    dots.forEach((d,i)=>{
      d.addEventListener('click', ()=> goSlide(i));
    });
    function goSlide(i){
      activeSlide = (i + 3) % 3;
      slides.style.transform = `translateX(-${activeSlide*100}%)`;
      dots.forEach((d,j)=> d.classList.toggle('active', j===activeSlide));
    }
    goSlide(0);

    function doConfetti(){
      // Lightweight confetti: create a few floating pieces
      const n = 24;
      for(let i=0;i<n;i++){
        const piece = document.createElement('div');
        piece.style.position='fixed';
        piece.style.left = (pointer.x|0) + 'px';
        piece.style.top  = (pointer.y|0) + 'px';
        piece.style.width = '8px'; piece.style.height = '12px';
        piece.style.borderRadius='2px';
        piece.style.background = `hsl(${(i*37)%360} 90% 60%)`;
        piece.style.transform = `translate(-50%,-50%) rotate(${(Math.random()*360)|0}deg)`;
        piece.style.zIndex='60';
        piece.style.pointerEvents='none';
        document.body.appendChild(piece);
        const dx = (Math.random()*2-1)*180;
        const dy = - (80 + Math.random()*220);
        const rot = (Math.random()*720-360);
        piece.animate([
          { transform:`translate(-50%,-50%) translate(0px,0px) rotate(0deg)`, opacity:1 },
          { transform:`translate(-50%,-50%) translate(${dx}px,${dy}px) rotate(${rot}deg)`, opacity:0 }
        ], { duration: 900 + Math.random()*700, easing:'cubic-bezier(.22,1,.36,1)' }).onfinish = ()=> piece.remove();
      }
    }

    // Simple toast
    let toastTimer;
    function toast(msg){
      hint.textContent = msg;
      hint.style.display = '';
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> hint.style.display = 'none', 1800);
    }

    // -----------------------------
    // MediaPipe callback: draw + gesture logic
    // -----------------------------
    hands.onResults((results)=>{
      const handsDetected = results.multiHandLandmarks?.length || 0;
      handsPill.classList.toggle('ok', handsDetected > 0);
      handsPill.classList.toggle('err', handsDetected === 0);
      handsPill.querySelector('.val').textContent = String(handsDetected);
      camCard.classList.toggle('detecting', handsDetected > 0);

      // Draw video frame and landmarks on overlay canvas
      // (We don't draw the raw frame here because <video> is visible underneath.)
      ctx.clearRect(0,0,overlay.width,overlay.height);

      if(handsDetected){
        for(const lm of results.multiHandLandmarks){
          drawConnectors(ctx, lm, Hands.HAND_CONNECTIONS, {color:'#6cf', lineWidth:2});
          drawLandmarks(ctx, lm, {color:'#f9f', lineWidth:1, radius:2.2});
        }

        // Use the first hand for cursor control
        const lm = results.multiHandLandmarks[0];
        const iTip = lm[8];

        // Convert to viewport coordinates; note MediaPipe gives normalized (0..1)
        const vp = toViewportCoords(iTip.x, iTip.y);

        // Update cursor
        cursor.classList.toggle('active', true);
        setCursor(vp.x, vp.y, true);

        // Maintain position history for swipe detection
        posHistory.push({x:vp.x, y:vp.y, t:performance.now()});
        if(posHistory.length > MAX_HISTORY) posHistory.shift();

        // Gesture detection (if enabled)
        let gestureLabel = 'Tracking';
        if(gestureEnabled){
          const pointing = isPointing(lm);
          const pinching = detectPinch(lm);

          // Update "Gesture" pill
          if(pinching) gestureLabel = 'Pinch';
          else if(pointing) gestureLabel = 'Point';
          else gestureLabel = 'Move';

          // Hover/highlight element under cursor
          const el = getTopGesturableElementAt(pointer.x, pointer.y);
          setHover(el);

          // Handle pinch click / drag
          if(pinching && !pinchActive){
            // Pinch started
            pinchActive = true;
            pinchJustStarted = true;
            cursor.classList.add('click');
            if(el){
              // If it's a slider, start dragging
              if(el.tagName === 'INPUT' && el.type === 'range'){
                draggingSlider = el;
                updateSliderAtPointer(draggingSlider);
              }else{
                pinchClick(el);
              }
            }
          }else if(pinching && pinchActive){
            // Continue pinch (drag on slider)
            if(draggingSlider){
              updateSliderAtPointer(draggingSlider);
            }
          }else if(!pinching && pinchActive){
            // Pinch ended
            pinchActive = false;
            pinchJustStarted = false;
            draggingSlider = null;
            cursor.classList.remove('click');
          }

          // Swipe detection (only when not dragging)
          if(!pinching && !draggingSlider){
            const swipe = maybeDetectSwipe();
            if(swipe){
              const target = document.elementFromPoint(pointer.x, pointer.y);
              const inCarousel = target && target.closest('#carousel');
              if(inCarousel){
                if(swipe === 'left') goSlide(activeSlide+1);
                if(swipe === 'right') goSlide(activeSlide-1);
              }
            }
          }
        }

        gestPill.classList.toggle('ok', true);
        gestPill.querySelector('.val').textContent = gestureEnabled ? gestureLabel : 'Off';
      }else{
        // No hands detected
        setHover(null);
        cursor.classList.remove('active','click');
        gestPill.classList.remove('ok');
        gestPill.querySelector('.val').textContent = 'Idle';
      }

      lastPointer = { x: pointer.x, y: pointer.y, t: performance.now() };
    });

    // -----------------------------
    // Initialize: camera + start
    // -----------------------------
    (async function init(){
      // Start camera immediately (if allowed). If blocked, the error banner explains.
      await startCamera();

      // Initialize MediaPipe (assets are loaded lazily on first send)
      // Nothing else needed here; hands.send() in loop triggers onResults.
    })();

    // Keep overlay sized to the video as it lays out
    const ro = new ResizeObserver(resizeOverlay);
    ro.observe(video);

    // Accessibility: spacebar to toggle gestures
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){
        e.preventDefault();
        gestureEnabled = !gestureEnabled;
        gestPill.querySelector('.val').textContent = gestureEnabled ? 'On' : 'Off';
        toast(`Gestures ${gestureEnabled ? 'enabled' : 'disabled'}`);
      }
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', stopCamera);

    // -----------------------------
    // Extra: prevent accidental page scroll on pinch gestures in mobile browsers
    // -----------------------------
    document.addEventListener('touchmove', (e)=>{
      if(pinchActive) e.preventDefault();
    }, {passive:false});
  </script>
</body>
</html>
