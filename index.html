<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Website</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 1200px;
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
        }
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .video-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }
        #inputVideo {
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #outputCanvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 15px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-panel {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        .control-panel h3 {
            color: white;
            margin-top: 0;
            text-align: center;
        }
        .interactive-button {
            width: 100%;
            height: 60px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .interactive-button:hover, .interactive-button.active {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ff5252, #d84315);
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        .drawing-area {
            width: 100%;
            height: 200px;
            background: rgba(255,255,255,0.9);
            border-radius: 15px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        .status {
            text-align: center;
            color: white;
            font-size: 18px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
        .gesture-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 1000;
        }
        @media (max-width: 768px) {
            .container { padding: 15px; }
            h1 { font-size: 2em; }
            .controls { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üñêÔ∏è Hand Tracking Interactive Website</h1>
        
        <div class="status" id="status">
            Click "Start Camera" to begin hand tracking
        </div>
        
        <div class="video-container">
            <video id="inputVideo" width="640" height="480" style="display: none;"></video>
            <canvas id="outputCanvas" width="640" height="480"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-panel">
                <h3>Camera Controls</h3>
                <button class="interactive-button" id="startBtn" onclick="startCamera()">Start Camera</button>
                <button class="interactive-button" id="stopBtn" onclick="stopCamera()" style="display: none;">Stop Camera</button>
            </div>
            
            <div class="control-panel">
                <h3>Interactive Buttons</h3>
                <button class="interactive-button" id="btn1" data-action="button1">Button 1</button>
                <button class="interactive-button" id="btn2" data-action="button2">Button 2</button>
                <button class="interactive-button" id="btn3" data-action="button3">Button 3</button>
            </div>
            
            <div class="control-panel">
                <h3>Hand-Controlled Sliders</h3>
                <div class="slider-container">
                    <label style="color: white;">Volume: <span id="volumeValue">50</span>%</label>
                    <input type="range" class="slider" id="volumeSlider" min="0" max="100" value="50">
                </div>
                <div class="slider-container">
                    <label style="color: white;">Brightness: <span id="brightnessValue">75</span>%</label>
                    <input type="range" class="slider" id="brightnessSlider" min="0" max="100" value="75">
                </div>
            </div>
            
            <div class="control-panel">
                <h3>Drawing Area</h3>
                <div class="drawing-area" id="drawingArea">
                    <canvas id="drawingCanvas" width="100%" height="200"></canvas>
                </div>
                <button class="interactive-button" onclick="clearDrawing()">Clear Drawing</button>
            </div>
        </div>
    </div>
    
    <div class="gesture-indicator" id="gestureIndicator">
        No hands detected
    </div>

    <script>
        let camera = null;
        let hands = null;
        let isDrawing = false;
        let lastDrawPoint = null;
        
        const videoElement = document.getElementById('inputVideo');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        
        // Initialize drawing canvas
        drawingCanvas.width = drawingCanvas.offsetWidth;
        drawingCanvas.height = drawingCanvas.offsetHeight;
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function updateGestureIndicator(message) {
            document.getElementById('gestureIndicator').textContent = message;
        }
        
        async function startCamera() {
            try {
                updateStatus('Requesting camera access...');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                
                videoElement.srcObject = stream;
                videoElement.style.display = 'block';
                
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'block';
                
                // Initialize MediaPipe Hands
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onResults);
                
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                updateStatus('Hand tracking active! Move your hands in front of the camera.');
                
            } catch (error) {
                updateStatus('Error accessing camera: ' + error.message);
                console.error('Camera error:', error);
            }
        }
        
        function stopCamera() {
            if (camera) {
                camera.stop();
            }
            
            if (videoElement.srcObject) {
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            
            videoElement.style.display = 'none';
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            
            updateStatus('Camera stopped');
            updateGestureIndicator('No hands detected');
        }
        
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                    drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });
                    
                    // Process hand gestures
                    processHandGestures(landmarks);
                }
                
                updateGestureIndicator(`${results.multiHandLandmarks.length} hand(s) detected`);
            } else {
                updateGestureIndicator('No hands detected');
                isDrawing = false;
                lastDrawPoint = null;
            }
            
            canvasCtx.restore();
        }
        
        function processHandGestures(landmarks) {
            // Get fingertip positions
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            const middleTip = landmarks[12];
            
            // Convert to screen coordinates
            const x = indexTip.x * canvasElement.width;
            const y = indexTip.y * canvasElement.height;
            
            // Check for pointing gesture (index finger extended)
            const isPointing = isFingerExtended(landmarks, 8) && !isFingerExtended(landmarks, 12);
            
            // Check for pinch gesture (thumb and index close)
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2)
            );
            const isPinching = distance < 0.05;
            
            // Handle button interactions
            if (isPointing) {
                checkButtonHover(x, y);
            }
            
            // Handle drawing
            if (isPinching) {
                handleDrawing(x, y);
            } else {
                isDrawing = false;
                lastDrawPoint = null;
            }
            
            // Handle slider control
            if (isPointing && !isPinching) {
                handleSliderControl(x, y);
            }
        }
        
        function isFingerExtended(landmarks, tipIndex) {
            const tip = landmarks[tipIndex];
            const pip = landmarks[tipIndex - 2];
            return tip.y < pip.y; // Finger is extended if tip is above PIP joint
        }
        
        function checkButtonHover(x, y) {
            const buttons = document.querySelectorAll('.interactive-button');
            buttons.forEach(button => {
                const rect = button.getBoundingClientRect();
                const canvasRect = canvasElement.getBoundingClientRect();
                
                // Adjust coordinates relative to canvas position
                const adjustedX = x + canvasRect.left;
                const adjustedY = y + canvasRect.top;
                
                if (adjustedX >= rect.left && adjustedX <= rect.right &&
                    adjustedY >= rect.top && adjustedY <= rect.bottom) {
                    button.classList.add('active');
                    // Simulate click after hover for 1 second
                    setTimeout(() => {
                        if (button.classList.contains('active')) {
                            button.click();
                        }
                    }, 1000);
                } else {
                    button.classList.remove('active');
                }
            });
        }
        
        function handleDrawing(x, y) {
            const drawingRect = drawingCanvas.getBoundingClientRect();
            const canvasRect = canvasElement.getBoundingClientRect();
            
            // Convert hand coordinates to drawing canvas coordinates
            const drawX = ((x + canvasRect.left - drawingRect.left) / drawingRect.width) * drawingCanvas.width;
            const drawY = ((y + canvasRect.top - drawingRect.top) / drawingRect.height) * drawingCanvas.height;
            
            if (drawX >= 0 && drawX <= drawingCanvas.width && drawY >= 0 && drawY <= drawingCanvas.height) {
                if (isDrawing && lastDrawPoint) {
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(lastDrawPoint.x, lastDrawPoint.y);
                    drawingCtx.lineTo(drawX, drawY);
                    drawingCtx.strokeStyle = '#ff6b6b';
                    drawingCtx.lineWidth = 3;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.stroke();
                }
                
                isDrawing = true;
                lastDrawPoint = { x: drawX, y: drawY };
            }
        }
        
        function handleSliderControl(x, y) {
            const sliders = document.querySelectorAll('.slider');
            sliders.forEach(slider => {
                const rect = slider.getBoundingClientRect();
                const canvasRect = canvasElement.getBoundingClientRect();
                
                const adjustedX = x + canvasRect.left;
                const adjustedY = y + canvasRect.top;
                
                if (adjustedX >= rect.left && adjustedX <= rect.right &&
                    adjustedY >= rect.top && adjustedY <= rect.bottom) {
                    
                    const percentage = (adjustedX - rect.left) / rect.width;
                    const value = Math.round(percentage * (slider.max - slider.min) + parseInt(slider.min));
                    slider.value = value;
                    
                    // Update display
                    if (slider.id === 'volumeSlider') {
                        document.getElementById('volumeValue').textContent = value;
                    } else if (slider.id === 'brightnessSlider') {
                        document.getElementById('brightnessValue').textContent = value;
                    }
                }
            });
        }
        
        function clearDrawing() {
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }
        
        // Button click handlers
        document.getElementById('btn1').addEventListener('click', () => {
            updateStatus('Button 1 activated by hand gesture!');
        });
        
        document.getElementById('btn2').addEventListener('click', () => {
            updateStatus('Button 2 activated by hand gesture!');
        });
        
        document.getElementById('btn3').addEventListener('click', () => {
            updateStatus('Button 3 activated by hand gesture!');
        });
        
        // Slider event listeners
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            document.getElementById('volumeValue').textContent = e.target.value;
        });
        
        document.getElementById('brightnessSlider').addEventListener('input', (e) => {
            document.getElementById('brightnessValue').textContent = e.target.value;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            drawingCanvas.width = drawingCanvas.offsetWidth;
            drawingCanvas.height = drawingCanvas.offsetHeight;
        });
        
        // Error handling for unsupported browsers
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            updateStatus('Camera access not supported in this browser');
        }
    </script>
</body>
</html>
